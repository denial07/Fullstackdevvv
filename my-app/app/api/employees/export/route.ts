import { NextRequest, NextResponse } from "next/server";
import { connectToDatabase } from "@/lib/mongodb";
import Employee from "@/lib/models/Employee";
import User from "@/lib/models/User";
import { jsPDF } from "jspdf";
import "jspdf-autotable";

// Extend jsPDF type to include autoTable
declare module "jspdf" {
  interface jsPDF {
    autoTable: (options: {
      head?: string[][];
      body?: string[][];
      startY?: number;
      styles?: object;
      headStyles?: object;
      alternateRowStyles?: object;
      margin?: object;
      didDrawPage?: (data: { pageNumber: number }) => void;
    }) => jsPDF;
  }
}

// Helper function to verify authentication token and get user info
async function verifyUser(request: NextRequest) {
  try {
    const token = request.cookies.get("auth-token")?.value;
    if (!token) {
      throw new Error("No token provided");
    }

    // Decode the session token (same format as login API)
    const decoded = JSON.parse(Buffer.from(token, 'base64').toString());
    
    // Check if token is expired (24 hours)
    if (Date.now() - decoded.timestamp > 24 * 60 * 60 * 1000) {
      throw new Error("Token expired");
    }

    await connectToDatabase();
    const user = await User.findById(decoded.userId).select("-password");
    
    if (!user) {
      throw new Error("User not found");
    }

    return user;
  } catch {
    throw new Error("Unauthorized");
  }
}

// POST /api/employees/export - Export employees to PDF
export async function POST(request: NextRequest) {
  try {
    const user = await verifyUser(request);
    
    // Check permissions
    if (user.role !== "Administrator" && user.role !== "Manager") {
      return NextResponse.json(
        { error: "Access denied. Manager or Administrator role required." },
        { status: 403 }
      );
    }

    const body = await request.json();
    const { filters = {}, includeFields = [] } = body;
    
    await connectToDatabase();

    // Build query based on user role and filters
    const query: Record<string, unknown> = {};

    // Role-based filtering
    if (user.role === "Manager") {
      query.department = user.department;
    }

    // Apply filters
    if (filters.search) {
      query.$or = [
        { firstName: { $regex: filters.search, $options: "i" } },
        { lastName: { $regex: filters.search, $options: "i" } },
        { employeeId: { $regex: filters.search, $options: "i" } },
        { email: { $regex: filters.search, $options: "i" } }
      ];
    }

    if (filters.department) {
      query.department = filters.department;
    }

    if (filters.status) {
      query.status = filters.status;
    }

    if (filters.jobTitle) {
      query.jobTitle = { $regex: filters.jobTitle, $options: "i" };
    }

    // Fetch employees
    const employees = await Employee.find(query)
      .sort({ lastName: 1, firstName: 1 })
      .lean();

    // Create PDF
    const doc = new jsPDF();
    const pageWidth = doc.internal.pageSize.width;
    const pageHeight = doc.internal.pageSize.height;

    // Header
    doc.setFontSize(18);
    doc.setFont("helvetica", "bold");
    
    let title = "Employee Directory";
    if (user.role === "Manager") {
      title += ` - ${user.department} Department`;
    }
    
    const titleWidth = doc.getTextWidth(title);
    doc.text(title, (pageWidth - titleWidth) / 2, 25);

    // Subtitle with filters
    doc.setFontSize(10);
    doc.setFont("helvetica", "normal");
    let subtitle = `Generated by: ${user.name} on ${new Date().toLocaleString()}`;
    
    if (Object.keys(filters).length > 0) {
      const appliedFilters = [];
      if (filters.department) appliedFilters.push(`Department: ${filters.department}`);
      if (filters.status) appliedFilters.push(`Status: ${filters.status}`);
      if (filters.jobTitle) appliedFilters.push(`Job Title: ${filters.jobTitle}`);
      if (filters.search) appliedFilters.push(`Search: ${filters.search}`);
      
      if (appliedFilters.length > 0) {
        subtitle += ` | Filters: ${appliedFilters.join(", ")}`;
      }
    }
    
    const subtitleLines = doc.splitTextToSize(subtitle, pageWidth - 40);
    doc.text(subtitleLines, 20, 35);

    // Define table columns
    const defaultFields = [
      { key: "employeeId", header: "ID" },
      { key: "fullName", header: "Name" },
      { key: "department", header: "Department" },
      { key: "jobTitle", header: "Job Title" },
      { key: "status", header: "Status" },
      { key: "dateOfJoining", header: "Join Date" }
    ];

    const availableFields = [
      ...defaultFields,
      { key: "email", header: "Email" },
      { key: "phone", header: "Phone" },
      { key: "manager", header: "Manager" }
    ];

    // Use specified fields or default fields
    const columnsToShow = includeFields.length > 0 
      ? availableFields.filter(field => includeFields.includes(field.key))
      : defaultFields;

    // Prepare table data
    const tableData = employees.map(emp => {
      const row: Record<string, string> = {};
      columnsToShow.forEach(col => {
        switch (col.key) {
          case "fullName":
            row[col.key] = `${emp.firstName} ${emp.lastName}`;
            break;
          case "dateOfJoining":
            row[col.key] = new Date(emp.dateOfJoining).toLocaleDateString();
            break;
          case "status":
            row[col.key] = emp.status.charAt(0).toUpperCase() + emp.status.slice(1);
            break;
          default:
            row[col.key] = (emp as Record<string, unknown>)[col.key] as string || "-";
        }
      });
      return row;
    });

    // Create table
    doc.autoTable({
      head: [columnsToShow.map(col => col.header)],
      body: tableData.map(row => columnsToShow.map(col => row[col.key])),
      startY: 50,
      styles: {
        fontSize: 8,
        cellPadding: 3,
      },
      headStyles: {
        fillColor: [41, 128, 185],
        textColor: 255,
        fontStyle: "bold",
      },
      alternateRowStyles: {
        fillColor: [245, 245, 245],
      },
      margin: { top: 50, left: 10, right: 10 },
      didDrawPage: function(data: { pageNumber: number }) {
        // Footer
        doc.setFontSize(8);
        doc.setTextColor(128);
        doc.text(
          `Page ${data.pageNumber}`,
          pageWidth - 30,
          pageHeight - 10
        );
        doc.text(
          `Total Employees: ${employees.length}`,
          20,
          pageHeight - 10
        );
      }
    });

    // Convert PDF to buffer
    const pdfBuffer = Buffer.from(doc.output("arraybuffer"));

    // Set response headers
    const headers = new Headers();
    headers.set("Content-Type", "application/pdf");
    headers.set("Content-Disposition", `attachment; filename="employee-directory-${new Date().toISOString().split('T')[0]}.pdf"`);
    headers.set("Content-Length", pdfBuffer.length.toString());

    return new NextResponse(pdfBuffer, {
      status: 200,
      headers
    });

  } catch (error: unknown) {
    const errorMessage = error instanceof Error ? error.message : "Failed to export employees";
    console.error("Error exporting employees:", error);
    return NextResponse.json(
      { error: errorMessage },
      { status: errorMessage === "Unauthorized" ? 401 : 500 }
    );
  }
}
